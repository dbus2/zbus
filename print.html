<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>zbus: D-Bus for Rust made easy</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zbus: D-Bus for Rust made easy</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dbus2/zbus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="zbus-pixels.gif" alt="zbus illustration" style="width: 100%;">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong><a href="https://github.com/dbus2/zbus">zbus</a></strong> is a <strong><a href="https://www.rust-lang.org/">Rust</a></strong> crate for <strong><a href="https://dbus.freedesktop.org/">D-Bus</a></strong>. If you are not familiar with D-Bus, you should
read <a href="https://www.freedesktop.org/wiki/Software/dbus/#index1h1">what is D-Bus?</a> first<sup class="footnote-reference" id="fr-outdated-1"><a href="#footnote-outdated">1</a></sup>. In short, zbus allows you to communicate from one program
to another, using the D-Bus protocol. In other words, it’s an <em>inter-process</em> communication (IPC)
solution. It is a very popular IPC solution on Linux and many Linux services (e.g systemd,
NetworkManager) and desktop environments (e.g GNOME and KDE), rely on D-Bus for their IPC needs.
There are many tools and implementations available, making it easy to interact with D-Bus programs
from different languages and environments.</p>
<p>zbus is a 100% Rust-native implementation of the D-Bus protocol. It provides both an API to send
and receive messages over a connection, as well as API to interact with peers through high-level
concepts like method calls, signals and properties<sup class="footnote-reference" id="fr-high-level-api-1"><a href="#footnote-high-level-api">2</a></sup>. Thanks to the power of Rust
macros, zbus is able to make interacting with D-Bus very easy.</p>
<p>zbus project provides two crates:</p>
<h2 id="zvariant"><a class="header" href="#zvariant">zvariant</a></h2>
<p>D-Bus defines a marshalling format for its messages. The <a href="https://crates.io/crates/zvariant">zvariant</a> crate provides a <a href="https://serde.rs/">serde</a>-based
<a href="https://docs.rs/zvariant/">API</a> to serialize/deserialize Rust data types to/from this format. Outside of D-Bus context, a
modified form of this format, <a href="https://developer.gnome.org/documentation/specifications/gvariant-specification-1.0.html">GVariant</a>
is very commonly used for efficient storage of arbitrary data and is also supported by this crate.</p>
<h2 id="zbus"><a class="header" href="#zbus">zbus</a></h2>
<p>The <a href="https://crates.io/crates/zbus">zbus crate</a> provides the main API you will use to interact with D-Bus from Rust. It takes care
of the establishment of a connection, the creation, sending and receiving of different kind of D-Bus
messages (method calls, signals etc) for you.</p>
<p align="center">
  <img src="https://www.freedesktop.org/png/freedesktop-logo.png" height="32"/>
</p>
<hr>
<ol class="footnote-definition"><li id="footnote-outdated">
<p>D-Bus is ~15y old, unfortunately many documents out there are
sometime aging or misleading. <a href="#fr-outdated-1">↩</a></p>
</li>
<li id="footnote-high-level-api">
<p>These concepts are explained in the
<a href="concepts.html#interfaces">following chapter</a>. <a href="#fr-high-level-api-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="some-d-bus-concepts-to-help-newcomers"><a class="header" href="#some-d-bus-concepts-to-help-newcomers">Some D-Bus concepts to help newcomers</a></h1>
<ul>
<li><a href="concepts.html#bus">Bus</a></li>
<li><a href="concepts.html#bus-name--service-name">Bus name / service name</a></li>
<li><a href="concepts.html#objects-and-object-paths">Objects and Object paths</a></li>
<li><a href="concepts.html#interfaces">Interfaces</a></li>
<li><a href="concepts.html#good-practices--api-design">Good practices &amp; API design</a></li>
</ul>
<h2 id="bus"><a class="header" href="#bus">Bus</a></h2>
<p>A D-Bus “bus” is a server that handles several connections in a bus-topology fashion. As such, it
relays messages between connected endpoints, and allows to discover endpoints or sending
broadcast messages (signals).</p>
<p>Typically, a Linux system has a system bus, and a session bus. The latter is per-user. It is also
possible to have private buses or no bus at all (i-e direct peer-to-peer communication instead).</p>
<h2 id="bus-name--service-name"><a class="header" href="#bus-name--service-name">Bus name / service name</a></h2>
<p>An endpoint can have various names, which allows to address messages to it on the bus. All endpoints
are assigned a unique name by the bus at start. Since this name is not static, most services use
something called a <em>well-known bus name</em> and typically it’s this name, that you’ll be concerned
with.</p>
<p>An example would be the <a href="https://specifications.freedesktop.org/notification-spec/latest/">FreeDesktop Notifications Service</a> that uses
<code>org.freedesktop.Notifications</code> as its well-known bus name.</p>
<p>For further details on bus names, please refer to the <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus">Bus names chapter</a> of the D-Bus specification.</p>
<h2 id="objects-and-object-paths"><a class="header" href="#objects-and-object-paths">Objects and Object paths</a></h2>
<p>An object is akin to the concept of an object or an instance in many programming languages. All
services expose at least one object on the bus and all clients interact with the service through
these objects. These objects can be ephemeral or they could live as long as the service itself.</p>
<p>Every object is identified by a string, which is referred to as its path. An example of an object
path is <code>/org/freedesktop/Notifications</code>, which identities the only object exposed by the
<a href="https://specifications.freedesktop.org/notification-spec/latest/">FreeDesktop Notifications Service</a>.</p>
<p>For further details on object paths, please refer to the <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#basic-types">Basic types chapter</a> of the D-Bus
specification.</p>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>An interface defines the API exposed by object on the bus. They are akin to the concept of
interfaces in many programming languages and traits in Rust. Each object can (and typically do)
provide multiple interfaces at the same time. A D-Bus interface can have methods, properties and
signals.</p>
<p>While each interface of a service is identified by a <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-interface">unique name</a>, its API is described by an XML
description. It is mostly a machine-level detail. Most services can be queried for this description
through a D-Bus standard <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-introspectable">introspection interface</a>.</p>
<p>zbus provides convenient macro that implements the introspection interface for services, and helper
to generate client-side Rust API, given an XML description. We’ll see both of these in action in the
following chapters.</p>
<h2 id="good-practices--api-design"><a class="header" href="#good-practices--api-design">Good practices &amp; API design</a></h2>
<p>It is recommended to organise the service name, object paths and interface name by using
fully-qualified domain names, in order to avoid potential conflicts.</p>
<p>Please read the <a href="https://dbus.freedesktop.org/doc/dbus-api-design.html">D-Bus API Design Guidelines</a> carefully for other similar considerations.</p>
<p>Onwards to implementation details &amp; examples!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="establishing-a-connection"><a class="header" href="#establishing-a-connection">Establishing a connection</a></h1>
<ul>
<li><a href="connection.html#connection-to-the-bus">Connection to the bus</a></li>
<li><a href="connection.html#using-a-custom-bus-address">Using a custom bus address</a></li>
<li><a href="connection.html#peer-to-peer-connection">Peer to peer connection</a></li>
</ul>
<p>The first thing you will have to do is to connect to a D-Bus bus or to a D-Bus peer. This is the
entry point of the zbus API.</p>
<h2 id="connection-to-the-bus"><a class="header" href="#connection-to-the-bus">Connection to the bus</a></h2>
<p>To connect to the session bus (the <em>per-user</em> bus), simply call <code>Connection::session()</code>. It
returns an instance of the connection (if all went well). Similarly, to connect to the system bus
(to communicate with services such as <a href="https://developer.gnome.org/NetworkManager/stable/spec.html">NetworkManager</a>, <a href="https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/doc">BlueZ</a> or <a href="https://www.freedesktop.org/software/systemd/man/latest/org.freedesktop.systemd1.html">PID1</a>), use
<code>Connection::system()</code>.</p>
<p>Moreover, it can be converted to a <a href="https://docs.rs/zbus/5/zbus/struct.MessageStream.html"><code>MessageStream</code></a> that implements <a href="https://docs.rs/futures/4/futures/stream/trait.Stream.html"><code>futures::stream::Stream</code></a>,
which can be used to conveniently receive messages, for the times when low-level API is
more appropriate for your use case.</p>
<p><strong>Note:</strong> it is common for a D-Bus library to provide a “shared” connection to a bus for a process:
all <code>session()</code> share the same underlying connection for example. At the time of this writing,
zbus doesn’t do that.</p>
<p><strong>Note:</strong> on macOS, there is no standard implicit way to connect to a session bus. zbus provides
opt-in compatibility to the Launchd session bus discovery mechanism via the <code>launchctl getenv</code> feature.
The official dbus installation method via <code>Homebrew</code> provides a session bus installation,
utilizing macOS <code>LaunchAgents</code> feature. By default, zbus consumes an address for a bus connection that
is provided via <code>launchctl getenv DBUS_LAUNCHD_SESSION_BUS_SOCKET</code> command output.</p>
<h2 id="using-a-custom-bus-address"><a class="header" href="#using-a-custom-bus-address">Using a custom bus address</a></h2>
<p>You may also specify a custom bus with <a href="https://docs.rs/zbus/5/zbus/connection/struct.Builder.html#method.address"><code>connection::Builder::address</code></a> which takes a D-Bus address
<a href="https://dbus.freedesktop.org/doc/dbus-specification.html#addresses">as specified in the specification</a>.</p>
<h2 id="peer-to-peer-connection"><a class="header" href="#peer-to-peer-connection">Peer to peer connection</a></h2>
<p>Peer-to-peer connections are bus-less<sup class="footnote-reference" id="fr-bus-less-1"><a href="#footnote-bus-less">1</a></sup>, and the initial handshake protocol is a bit
different. There is the notion of client &amp; server endpoints, but that distinction doesn’t matter
once the connection is established (both ends are equal, and can send any messages).</p>
<p>For example to create a bus-less peer-to-peer connection on Unix, you can do:</p>
<pre><code class="language-rust noplayground"><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; zbus::Result&lt;()&gt; {
</span><span class="boring">#[cfg(unix)]
</span><span class="boring">{
</span>#[cfg(not(feature = "tokio"))]
use std::os::unix::net::UnixStream;
#[cfg(feature = "tokio")]
use tokio::net::UnixStream;
use zbus::{connection::Builder, Guid};

let guid = Guid::generate();
let (p0, p1) = UnixStream::pair().unwrap();
<span class="boring">#[allow(unused)]
</span>let (client_conn, server_conn) = futures_util::try_join!(
    // Client
    Builder::unix_stream(p0).p2p().build(),
    // Server
    Builder::unix_stream(p1).server(guid)?.p2p().build(),
)?;
<span class="boring">}
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p><strong>Note:</strong> the <code>p2p</code> and <code>server</code> methods of <code>connection::Builder</code> are only available when <code>p2p</code>
cargo feature of <code>zbus</code> is enabled.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-bus-less">
<p>Unless you implemented them, none of the bus methods will exist. <a href="#fr-bus-less-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-client-proxy"><a class="header" href="#writing-a-client-proxy">Writing a client proxy</a></h1>
<ul>
<li><a href="client.html#low-level-call-from-a-zbusconnection">Low-level call from a <code>zbus::Connection</code></a></li>
<li><a href="client.html#trait-derived-proxy-call">Trait-derived proxy call</a>
<ul>
<li><a href="client.html#signals">Signals</a>
<ul>
<li><a href="client.html#more-advanced-example">More advanced example</a></li>
</ul>
</li>
<li><a href="client.html#properties">Properties</a>
<ul>
<li><a href="client.html#trait-bounds-for-property-values">Trait-bounds for property values</a></li>
<li><a href="client.html#watching-for-changes">Watching for changes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="client.html#generating-the-trait-from-an-xml-interface">Generating the trait from an XML interface</a></li>
</ul>
<p>In this chapter, we are going to see how to make low-level D-Bus method calls. Then we are going to
dive in, and derive from a trait to make a convenient Rust binding. Finally, we will learn about
<em>xmlgen</em>, a tool to help us generate a boilerplate trait from the XML of an introspected service.</p>
<p>To make this learning “hands-on”, we are going to call and bind the cross-desktop notification
service (please refer to this
<a href="https://specifications.freedesktop.org/notification-spec/latest/">reference</a>
document for further details on this API).</p>
<p>Let’s start by playing with the service from the shell, and notify the desktop with [<code>busctl</code>]<sup class="footnote-reference" id="fr-busctl-1"><a href="#footnote-busctl">1</a></sup>:</p>
<pre><code class="language-bash">busctl --user call \
  org.freedesktop.Notifications \
  /org/freedesktop/Notifications \
  org.freedesktop.Notifications \
  Notify \
  susssasa\{sv\}i \
  "my-app" 0 "dialog-information" "A summary" "Some body" 0 0 5000
</code></pre>
<p><strong>Note</strong>: <code>busctl</code> has very good auto-completion support in bash or zsh.</p>
<p>Running this command should pop-up a notification dialog on your desktop. If it does not, your
desktop does not support the notification service, and this example will be less interactive.
Nonetheless you can use a similar approach for other services.</p>
<p>This command shows us several aspects of the D-Bus communication:</p>
<ul>
<li>
<p><code>--user</code>: Connect to and use the user/session bus.</p>
</li>
<li>
<p><code>call</code>: Send a method call message. (D-Bus also supports signals, error messages, and method
replies)</p>
</li>
<li>
<p><strong>destination</strong>: The name of the service (<code>org.freedesktop.Notifications</code>).</p>
</li>
<li>
<p><strong>object path</strong>: Object/interface path (<code>/org/freedesktop/Notifications</code>).</p>
</li>
<li>
<p><strong>interface</strong>: The interface name (methods are organized in interfaces, here
<code>org.freedesktop.Notifications</code>, same name as the service).</p>
</li>
<li>
<p><strong>method</strong>: The name of the method to call, <code>Notify</code>.</p>
</li>
<li>
<p><strong>signature</strong>: That <code>susssasa{sv}i</code> means the method takes 8 arguments of various types. ‘s’, for
example, is for a string. ‘as’ is for array of strings.</p>
</li>
<li>
<p>The method arguments.</p>
</li>
</ul>
<p>See <a href="https://www.freedesktop.org/software/systemd/man/busctl.html"><code>busctl</code></a> man page for more details.</p>
<h2 id="low-level-call-from-a-zbusconnection"><a class="header" href="#low-level-call-from-a-zbusconnection">Low-level call from a <code>zbus::Connection</code></a></h2>
<p>zbus <code>Connection</code> has a <code>call_method()</code> method, which you can use directly:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::collections::HashMap;
use std::error::Error;

use zbus::{zvariant::Value, Connection};

// Although we use `tokio` here, you can use any async runtime of choice.
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let connection = Connection::session().await?;

    let m = connection.call_method(
        Some("org.freedesktop.Notifications"),
        "/org/freedesktop/Notifications",
        Some("org.freedesktop.Notifications"),
        "Notify",
        &amp;("my-app", 0u32, "dialog-information", "A summary", "Some body",
          vec![""; 0], HashMap::&lt;&amp;str, &amp;Value&gt;::new(), 5000),
    ).await?;
    let reply: u32 = m.body().deserialize().unwrap();
    dbg!(reply);
    Ok(())
}</code></pre></pre>
<p>Although this is already quite flexible, and handles various details for you (such as the message
signature), it is also somewhat inconvenient and error-prone: you can easily miss arguments, or give
arguments with the wrong type or other kind of errors (what would happen if you typed <code>0</code>, instead
of <code>0u32</code>?).</p>
<p>Instead, we want to wrap this <code>Notify</code> D-Bus method in a Rust function. Let’s see how next.</p>
<h2 id="trait-derived-proxy-call"><a class="header" href="#trait-derived-proxy-call">Trait-derived proxy call</a></h2>
<p>A trait declaration <code>T</code> with a <code>proxy</code> attribute will have a derived <code>TProxy</code> and
<code>TProxyBlocking</code> (see <a href="blocking.html">chapter on “blocking”</a> for more information on that) implemented thanks
to procedural macros. The trait methods will have respective <code>impl</code> methods wrapping the D-Bus
calls:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::collections::HashMap;
use std::error::Error;

use zbus::{zvariant::Value, proxy, Connection};

#[proxy(
    default_service = "org.freedesktop.Notifications",
    default_path = "/org/freedesktop/Notifications"
)]
trait Notifications {
    /// Call the org.freedesktop.Notifications.Notify D-Bus method
    fn notify(&amp;self,
              app_name: &amp;str,
              replaces_id: u32,
              app_icon: &amp;str,
              summary: &amp;str,
              body: &amp;str,
              actions: &amp;[&amp;str],
              hints: HashMap&lt;&amp;str, &amp;Value&lt;'_&gt;&gt;,
              expire_timeout: i32) -&gt; zbus::Result&lt;u32&gt;;
}

// Although we use `tokio` here, you can use any async runtime of choice.
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let connection = Connection::session().await?;

    let proxy = NotificationsProxy::new(&amp;connection).await?;
    let reply = proxy.notify(
        "my-app",
        0,
        "dialog-information",
        "A summary", "Some body",
        &amp;[],
        HashMap::new(),
        5000,
    ).await?;
    dbg!(reply);

    Ok(())
}</code></pre></pre>
<p>A <code>TProxy</code> and <code>TProxyBlocking</code> has a few associated methods, such as <code>new(connection)</code>, using the
default associated service name and object path, and an associated builder if you need to specify
something different.</p>
<p>This should help to avoid the kind of mistakes we saw earlier. It’s also a bit easier to use, thanks
to Rust type inference. This makes it also possible to have higher-level types, they fit more
naturally with the rest of the code. You can further document the D-Bus API or provide additional
helpers.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>For simple transient cases like the one above, you may find the <a href="blocking.html">blocking API</a> very
convenient to use.</p>
</blockquote>
<h3 id="signals"><a class="header" href="#signals">Signals</a></h3>
<p>Signals are like methods, except they don’t expect a reply. They are typically emitted by services
to notify interested peers of any changes to the state of the service. zbus provides you a
<a href="https://docs.rs/futures/4/futures/stream/trait.Stream.html"><code>Stream</code></a>-based API for receiving signals.</p>
<p>Let’s look at this API in action, with an example where we monitor started systemd units.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">// NOTE: When changing this, please also keep `zbus/examples/watch-systemd-jobs.rs` in sync.
</span>use futures_util::stream::StreamExt;
use zbus::{zvariant::OwnedObjectPath, proxy, Connection};

<span class="boring">fn main() {
</span><span class="boring">    async_io::block_on(watch_systemd_jobs()).expect("Error listening to signal");
</span><span class="boring">}
</span>
#[proxy(
    default_service = "org.freedesktop.systemd1",
    default_path = "/org/freedesktop/systemd1",
    interface = "org.freedesktop.systemd1.Manager"
)]
trait Systemd1Manager {
    // Defines signature for D-Bus signal named `JobNew`
    #[zbus(signal)]
    fn job_new(&amp;self, id: u32, job: OwnedObjectPath, unit: String) -&gt; zbus::Result&lt;()&gt;;
}

async fn watch_systemd_jobs() -&gt; zbus::Result&lt;()&gt; {
    let connection = Connection::system().await?;
    // `Systemd1ManagerProxy` is generated from `Systemd1Manager` trait
    let systemd_proxy = Systemd1ManagerProxy::new(&amp;connection).await?;
    // Method `receive_job_new` is generated from `job_new` signal
    let mut new_jobs_stream = systemd_proxy.receive_job_new().await?;

    while let Some(msg) = new_jobs_stream.next().await {
        // struct `JobNewArgs` is generated from `job_new` signal function arguments
        let args: JobNewArgs = msg.args().expect("Error parsing message");

        println!(
            "JobNew received: unit={} id={} path={}",
            args.unit, args.id, args.job
        );
    }

    panic!("Stream ended unexpectedly");
}</code></pre></pre>
<h4 id="more-advanced-example"><a class="header" href="#more-advanced-example">More advanced example</a></h4>
<p>Here is a more elaborate example, where we get our location from
<a href="https://gitlab.freedesktop.org/geoclue/geoclue/-/blob/master/README.md">Geoclue</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use zbus::{zvariant::ObjectPath, proxy, Connection, Result};
use futures_util::stream::StreamExt;

#[proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Manager",
    default_path = "/org/freedesktop/GeoClue2/Manager"
)]
trait Manager {
    #[zbus(object = "Client")]
    fn get_client(&amp;self);
}

#[proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Client"
)]
trait Client {
    fn start(&amp;self) -&gt; Result&lt;()&gt;;
    fn stop(&amp;self) -&gt; Result&lt;()&gt;;

    #[zbus(property)]
    fn set_desktop_id(&amp;mut self, id: &amp;str) -&gt; Result&lt;()&gt;;

    #[zbus(signal)]
    fn location_updated(&amp;self, old: ObjectPath&lt;'_&gt;, new: ObjectPath&lt;'_&gt;) -&gt; Result&lt;()&gt;;
}

#[proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Location"
)]
trait Location {
    #[zbus(property)]
    fn latitude(&amp;self) -&gt; Result&lt;f64&gt;;
    #[zbus(property)]
    fn longitude(&amp;self) -&gt; Result&lt;f64&gt;;
}

// Although we use `tokio` here, you can use any async runtime of choice.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let conn = Connection::system().await?;
    let manager = ManagerProxy::new(&amp;conn).await?;
    let mut client = manager.get_client().await?;
    // Gotta do this, sorry!
    client.set_desktop_id("org.freedesktop.zbus").await?;

    let props = zbus::fdo::PropertiesProxy::builder(&amp;conn)
        .destination("org.freedesktop.GeoClue2")?
        .path(client.inner().path())?
        .build()
        .await?;
    let mut props_changed = props.receive_properties_changed().await?;
    let mut location_updated = client.receive_location_updated().await?;

    client.start().await?;

    futures_util::try_join!(
        async {
            while let Some(signal) = props_changed.next().await {
                let args = signal.args()?;

                for (name, value) in args.changed_properties().iter() {
                    println!("{}.{} changed to `{:?}`", args.interface_name(), name, value);
                }
            }

            Ok::&lt;(), zbus::Error&gt;(())
        },
        async {
            while let Some(signal) = location_updated.next().await {
                let args = signal.args()?;

                let location = LocationProxy::builder(&amp;conn)
                    .path(args.new())?
                    .build()
                    .await?;
                println!(
                    "Latitude: {}\nLongitude: {}",
                    location.latitude().await?,
                    location.longitude().await?,
                );
            }

            // No need to specify type of Result each time
            Ok(())
        }
    )?;

   Ok(())
}</code></pre></pre>
<p>While the Geoclue’s D-Bus API is a bit involved, we still ended-up with a not-so-complicated (~100
LOC) code for getting our location.</p>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>Interfaces can have associated properties, which can be read or set with the
<code>org.freedesktop.DBus.Properties</code> interface. Here again, the <code>#[proxy]</code> attribute comes to the
rescue to help you. You can annotate a trait method to be a getter:</p>
<pre><code class="language-rust noplayground"><span class="boring">use zbus::{proxy, Result};
</span><span class="boring">
</span>#[proxy]
trait MyInterface {
    #[zbus(property)]
    fn state(&amp;self) -&gt; Result&lt;String&gt;;
}</code></pre>
<p>The <code>state()</code> method will translate to a <code>"State"</code> property <code>Get</code> call.</p>
<p>To set the property, prefix the name of the property with <code>set_</code>.</p>
<p>For a more real world example, let’s try and read two properties from systemd’s main service:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use zbus::{Connection, proxy, Result};
</span><span class="boring">
</span>#[proxy(
    interface = "org.freedesktop.systemd1.Manager",
    default_service = "org.freedesktop.systemd1",
    default_path = "/org/freedesktop/systemd1"
)]
trait SystemdManager {
    #[zbus(property)]
    fn architecture(&amp;self) -&gt; Result&lt;String&gt;;
    #[zbus(property)]
    fn environment(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;&gt;;
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let connection = Connection::system().await?;

    let proxy = SystemdManagerProxy::new(&amp;connection).await?;
    println!("Host architecture: {}", proxy.architecture().await?);
    println!("Environment variables:");
    for env in proxy.environment().await? {
        println!("  {}", env);
    }

    Ok(())
}</code></pre></pre>
<p>You should get an output similar to this:</p>
<pre><code class="language-none">Host architecture: x86-64
Environment variables:
  HOME=/home/zeenix
  LANG=en_US.UTF-8
  LC_ADDRESS=de_DE.UTF-8
  LC_IDENTIFICATION=de_DE.UTF-8
  LC_MEASUREMENT=de_DE.UTF-8
  LC_MONETARY=de_DE.UTF-8
  LC_NAME=de_DE.UTF-8
  LC_NUMERIC=de_DE.UTF-8
  LC_PAPER=de_DE.UTF-8
  LC_TELEPHONE=de_DE.UTF-8
  LC_TIME=de_DE.UTF-8
  ...
</code></pre>
<h4 id="trait-bounds-for-property-values"><a class="header" href="#trait-bounds-for-property-values">Trait-bounds for property values</a></h4>
<p>If you use custom types for property values, you might get a compile error for missing
<code>TryFrom&lt;zvariant::Value&lt;'_&gt;&gt;</code> and/or <code>TryFrom&lt;OwnedValue&gt;</code> implementations. This is because
properties are always sent as Variants on the bus, so you need to implement these conversions for
your custom types.</p>
<p>Not to worry though, the <code>zvariant</code> crate provides a <a href="https://docs.rs/zvariant/5/zvariant/derive.Value.html"><code>Value</code></a> and <a href="https://docs.rs/zvariant/5/zvariant/derive.OwnedValue.html"><code>OwnedValue</code></a> derive macro to
implement these conversions for you.</p>
<h4 id="watching-for-changes"><a class="header" href="#watching-for-changes">Watching for changes</a></h4>
<p>By default, the proxy will cache the properties and watch for changes.</p>
<p>To be notified of a property change, you use a stream API, just like for receiving signals. The
methods are named after the properties’ names: <code>receive_&lt;prop_name&gt;_changed()</code>.</p>
<p>Here is an example:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use zbus::{Connection, proxy, Result};
</span><span class="boring">use futures_util::stream::StreamExt;
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;()&gt; {
</span>    #[proxy(
        interface = "org.freedesktop.systemd1.Manager",
        default_service = "org.freedesktop.systemd1",
        default_path = "/org/freedesktop/systemd1"
    )]
    trait SystemdManager {
        #[zbus(property)]
        fn log_level(&amp;self) -&gt; Result&lt;String&gt;;
    }

    let connection = Connection::system().await?;

    let proxy = SystemdManagerProxy::new(&amp;connection).await?;
    let mut stream = proxy.receive_log_level_changed().await;
    while let Some(v) = stream.next().await {
        println!("LogLevel changed: {:?}", v.get().await);
    }
<span class="boring">
</span><span class="boring">  Ok(())
</span><span class="boring">}</span></code></pre></pre>
<h2 id="generating-the-trait-from-an-xml-interface"><a class="header" href="#generating-the-trait-from-an-xml-interface">Generating the trait from an XML interface</a></h2>
<p>The <code>zbus_xmlgen</code> crate provides a <a href="https://crates.io/crates/zbus_xmlgen">developer-friendly tool</a>, that can generate Rust traits from a
given D-Bus introspection XML for you.</p>
<p><strong>Note:</strong> This tool should not be considered a drop-in Rust-specific replacement for similar tools
available for low-level languages, such as <a href="https://docs.gtk.org/gio/migrating-gdbus.html#generating-code-and-docs"><code>gdbus-codegen</code></a>. Unlike those tools, this is only meant
as a starting point to generate the code, once. In many cases, you will want to tweak the generated
code.</p>
<p>The tool can be used to generate rust code directly from a D-Bus service running on our system:</p>
<pre><code class="language-bash">zbus-xmlgen session \
  org.freedesktop.Notifications \
  /org/freedesktop/Notifications
</code></pre>
<p>Alternatively you can also get the XML interface from a different source and use it to generate the
interface code. Some packages may also provide the XML directly as an installed file, allowing it to
be queried using <a href="https://www.freedesktop.org/wiki/Software/pkg-config/"><code>pkg-config</code></a>, for example.</p>
<p>We can fetch the XML interface of the notification service, using the <code>--xml-interface</code> option of
the <code>busctl</code><sup class="footnote-reference" id="fr-busctl-2"><a href="#footnote-busctl">1</a></sup> command. This option was introduced to <code>busctl</code> in systemd v243.</p>
<pre><code class="language-bash">busctl --user --xml-interface introspect \
  org.freedesktop.Notifications \
  /org/freedesktop/Notifications
</code></pre>
<p>You should get a similar output:</p>
<pre><code class="language-xml">&lt;!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
                      "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd"&gt;
&lt;node&gt;
  &lt;!-- other interfaces omitted --&gt;
  &lt;interface name="org.freedesktop.Notifications"&gt;
    &lt;method name="Notify"&gt;
      &lt;arg type="s" name="arg_0" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="u" name="arg_1" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_2" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_3" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_4" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="as" name="arg_5" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="a{sv}" name="arg_6" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="i" name="arg_7" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="u" name="arg_8" direction="out"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;method name="CloseNotification"&gt;
      &lt;arg type="u" name="arg_0" direction="in"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;method name="GetCapabilities"&gt;
      &lt;arg type="as" name="arg_0" direction="out"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;method name="GetServerInformation"&gt;
      &lt;arg type="s" name="arg_0" direction="out"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_1" direction="out"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_2" direction="out"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_3" direction="out"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;signal name="NotificationClosed"&gt;
      &lt;arg type="u" name="arg_0"&gt;
      &lt;/arg&gt;
      &lt;arg type="u" name="arg_1"&gt;
      &lt;/arg&gt;
    &lt;/signal&gt;
    &lt;signal name="ActionInvoked"&gt;
      &lt;arg type="u" name="arg_0"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_1"&gt;
      &lt;/arg&gt;
    &lt;/signal&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</code></pre>
<p>Save the output to a <code>notify.xml</code> file. Then call:</p>
<pre><code class="language-bash">zbus-xmlgen file notify.xml
</code></pre>
<p>This will give back effortlessly the corresponding Rust traits boilerplate
code:</p>
<pre><code class="language-rust noplayground"><span class="boring">use zbus::proxy;
</span><span class="boring">
</span>#[proxy(
    interface = "org.freedesktop.Notifications",
    default_service = "org.freedesktop.Notifications",
    default_path= "/org/freedesktop/Notifications",
)]
trait Notifications {
    /// CloseNotification method
    fn close_notification(&amp;self, arg_0: u32) -&gt; zbus::Result&lt;()&gt;;

    /// GetCapabilities method
    fn get_capabilities(&amp;self) -&gt; zbus::Result&lt;Vec&lt;String&gt;&gt;;

    /// GetServerInformation method
    fn get_server_information(&amp;self) -&gt; zbus::Result&lt;(String, String, String, String)&gt;;

    /// Notify method
    fn notify(
        &amp;self,
        arg_0: &amp;str,
        arg_1: u32,
        arg_2: &amp;str,
        arg_3: &amp;str,
        arg_4: &amp;str,
        arg_5: &amp;[&amp;str],
        arg_6: std::collections::HashMap&lt;&amp;str, zvariant::Value&lt;'_&gt;&gt;,
        arg_7: i32,
    ) -&gt; zbus::Result&lt;u32&gt;;

    /// ActionInvoked signal
    #[zbus(signal)]
    fn action_invoked(&amp;self, arg_0: u32, arg_1: &amp;str) -&gt; zbus::Result&lt;()&gt;;

    /// NotificationClosed signal
    #[zbus(signal)]
    fn notification_closed(&amp;self, arg_0: u32, arg_1: u32) -&gt; zbus::Result&lt;()&gt;;
}</code></pre>
<p>It should be usable as such. But you may as well improve a bit the naming of the arguments, use
better types (using <code>BitFlags</code>, structs or other custom types), add extra documentation, and other
functions to make the binding more pleasing to use from Rust.</p>
<p>For example, the generated <code>GetServerInformation</code> method can be improved to a nicer version:</p>
<pre><code class="language-rust noplayground"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">use zbus::{zvariant::Type, proxy};
</span><span class="boring">
</span>#[derive(Debug, Type, Serialize, Deserialize)]
pub struct ServerInformation {
    /// The product name of the server.
    pub name: String,

    /// The vendor name. For example "KDE," "GNOME," "freedesktop.org" or "Microsoft".
    pub vendor: String,

    /// The server's version number.
    pub version: String,

    /// The specification version the server is compliant with.
    pub spec_version: String,
}

#[proxy(
    interface = "org.freedesktop.Notifications",
    default_service = "org.freedesktop.Notifications",
    default_path= "/org/freedesktop/Notifications",
)]
trait Notifications {
    /// Get server information.
    ///
    /// This message returns the information on the server.
    fn get_server_information(&amp;self) -&gt; zbus::Result&lt;ServerInformation&gt;;
}</code></pre>
<p>You can learn more from the zbus-ify <a href="https://github.com/dbus2/zbus_polkit">binding of
PolicyKit</a>, for example, which was
implemented starting from the <em>xmlgen</em> output.</p>
<p>There you have it, a Rust-friendly binding for your D-Bus service!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-busctl">
<p><code>busctl</code> is part of <a href="https://systemd.io/"><code>systemd</code></a>. <a href="#fr-busctl-1">↩</a> <a href="#fr-busctl-2">↩2</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-service-interface"><a class="header" href="#writing-a-service-interface">Writing a service interface</a></h1>
<ul>
<li><a href="service.html#taking-a-service-name">Taking a service name</a>
<ul>
<li><a href="service.html#-hang-on">🖐 Hang on</a></li>
</ul>
</li>
<li><a href="service.html#handling-low-level-messages">Handling low-level messages</a></li>
<li><a href="service.html#using-the-objectserver">Using the <code>ObjectServer</code></a>
<ul>
<li><a href="service.html#mygreeter-simple-example"><code>MyGreeter</code> simple example</a></li>
<li><a href="service.html#-service-activation-pitfalls">⚠ Service activation pitfalls</a></li>
<li><a href="service.html#a-more-complete-example">A more complete example</a></li>
<li><a href="service.html#trait-bounds-for-property-values">Trait-bounds for property values</a></li>
<li><a href="service.html#method-errors">Method errors</a></li>
<li><a href="service.html#sending-signals">Sending signals</a></li>
<li><a href="service.html#notifying-property-changes">Notifying property changes</a></li>
</ul>
</li>
<li><a href="service.html#proxy-generation">Proxy generation</a>
<ul>
<li><a href="service.html#known-limitations">Known Limitations</a></li>
</ul>
</li>
</ul>
<p>In this chapter, we are going to implement a service with a method “SayHello”, to greet back the
calling client.</p>
<p>We will first discuss the need to associate a service name with the service. Then we are going to
manually handle incoming messages using the low-level API. Finally, we will present the
<code>ObjectServer</code> higher-level API and some of its more advanced concepts.</p>
<h2 id="taking-a-service-name"><a class="header" href="#taking-a-service-name">Taking a service name</a></h2>
<p>As we know from the chapter on <a href="concepts.html#bus-name--service-name">D-Bus concepts</a>, each connection on the bus is given a unique name
(such as “:1.27”). This could be all you need, depending on your use case, and the design of your
D-Bus API. However, typically services use a service name (aka <em>well-known name</em>) so peers (clients,
in this context) can easily discover them.</p>
<p>In this example, that is exactly what we’re going to do and request the bus for the service name of
our choice:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use zbus::{Connection, Result};

// Although we use `tokio` here, you can use any async runtime of choice.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let connection = Connection::session()
        .await?;
    connection
        .request_name("org.zbus.MyGreeter")
        .await?;

    loop {}
}</code></pre></pre>
<p>We can check our service is running and is associated with the service name:</p>
<pre><code class="language-bash">$ busctl --user list | grep zbus
org.zbus.MyGreeter                             412452 service           elmarco :1.396        user@1000.service -       -
</code></pre>
<h3 id="-hang-on"><a class="header" href="#-hang-on">🖐 Hang on</a></h3>
<p>This example is not handling incoming messages yet. Any attempt to call the service will time out
(including the shell completion!).</p>
<h2 id="handling-low-level-messages"><a class="header" href="#handling-low-level-messages">Handling low-level messages</a></h2>
<p>At the low-level, you can handle method calls by checking the incoming messages manually.</p>
<p>Let’s write a <code>SayHello</code> method, that takes a string as argument, and reply with a “hello” greeting
by replacing the loop above with this code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use futures_util::stream::TryStreamExt;

// Although we use `tokio` here, you can use any async runtime of choice.
<span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; zbus::Result&lt;()&gt; {
</span><span class="boring">   let connection = zbus::Connection::session()
</span><span class="boring">       .await?;
</span>let mut stream = zbus::MessageStream::from(&amp;connection);
<span class="boring">   connection
</span><span class="boring">       .request_name("org.zbus.MyGreeter")
</span><span class="boring">       .await?;
</span><span class="boring">
</span>while let Some(msg) = stream.try_next().await? {
    let msg_header = msg.header();
    dbg!(&amp;msg);

    match msg_header.message_type() {
        zbus::message::Type::MethodCall =&gt; {
            // real code would check msg_header path(), interface() and member()
            // handle invalid calls, introspection, errors etc
            let header = msg.header();
            let body = msg.body();
            let arg: &amp;str = body.deserialize()?;
            connection.reply(&amp;header, &amp;(format!("Hello {}!", arg))).await?;

            break;
        }
        _ =&gt; continue,
    }
}

<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>And check if it works as expected:</p>
<pre><code class="language-bash">$ busctl --user call org.zbus.MyGreeter /org/zbus/MyGreeter org.zbus.MyGreeter1 SayHello s "zbus"
s "Hello zbus!"
</code></pre>
<p>This is the crust of low-level message handling. It should give you all the flexibility you ever
need, but it is also easy to get it wrong. Fortunately, zbus has a simpler solution to offer.</p>
<h2 id="using-the-objectserver"><a class="header" href="#using-the-objectserver">Using the <code>ObjectServer</code></a></h2>
<p>One can write an <code>impl</code> block with a set of methods and let the <code>interface</code> procedural macro
write the D-Bus message handling details. It will dispatch the incoming method calls to their
respective handlers, as well as replying to introspection requests.</p>
<h3 id="mygreeter-simple-example"><a class="header" href="#mygreeter-simple-example"><code>MyGreeter</code> simple example</a></h3>
<p>Let see how to use it for <code>MyGreeter</code> interface:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use zbus::{Connection, interface, Result};
</span><span class="boring">
</span>
struct Greeter;

#[interface(name = "org.zbus.MyGreeter1")]
impl Greeter {
    async fn say_hello(&amp;self, name: &amp;str) -&gt; String {
        format!("Hello {}!", name)
    }
}

// Although we use `tokio` here, you can use any async runtime of choice.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let connection = Connection::session().await?;
    // setup the object server
    connection
        .object_server()
        .at("/org/zbus/MyGreeter", Greeter)
        .await?;
    // before requesting the name
    connection
        .request_name("org.zbus.MyGreeter")
        .await?;

    loop {
        // do something else, wait forever or timeout here:
        // handling D-Bus messages is done in the background
        std::future::pending::&lt;()&gt;().await;
    }
}</code></pre></pre>
<h3 id="-service-activation-pitfalls"><a class="header" href="#-service-activation-pitfalls">⚠ Service activation pitfalls</a></h3>
<p>A possible footgun here is that you must request the service name <strong>after</strong> you setup the handlers,
otherwise incoming messages may be lost. Activated services may receive calls (or messages) right
after taking their name. This is why it’s typically better to make use of <code>connection::Builder</code> for
setting up your interfaces and requesting names, and not have to care about this:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use zbus::{connection, interface, Result};
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct Greeter;
</span><span class="boring">
</span><span class="boring">#[interface(name = "org.zbus.MyGreeter1")]
</span><span class="boring">impl Greeter {
</span><span class="boring">    async fn say_hello(&amp;self, name: &amp;str) -&gt; String {
</span><span class="boring">        format!("Hello {}!", name)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;()&gt; {
</span>    let _connection = connection::Builder::session()?
        .name("org.zbus.MyGreeter")?
        .serve_at("/org/zbus/MyGreeter", Greeter)?
        .build()
        .await?;
<span class="boring">    loop {
</span><span class="boring">        // do something else, wait forever or timeout here:
</span><span class="boring">        // handling D-Bus messages is done in the background
</span><span class="boring">        std::future::pending::&lt;()&gt;().await;
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>It should work with the same <code>busctl</code> command used previously.</p>
<p>This time, we can also introspect the service:</p>
<pre><code class="language-bash">$ busctl --user introspect org.zbus.MyGreeter /org/zbus/MyGreeter
NAME                                TYPE      SIGNATURE RESULT/VALUE FLAGS
org.freedesktop.DBus.Introspectable interface -         -             -
.Introspect                         method    -         s             -
org.freedesktop.DBus.Peer           interface -         -             -
.GetMachineId                       method    -         s             -
.Ping                               method    -         -             -
org.freedesktop.DBus.Properties     interface -         -             -
.Get                                method    ss        v             -
.GetAll                             method    s         a{sv}         -
.Set                                method    ssv       -             -
.PropertiesChanged                  signal    sa{sv}as  -             -
org.zbus.MyGreeter1                 interface -         -             -
.SayHello                           method    s         s             -
</code></pre>
<h3 id="a-more-complete-example"><a class="header" href="#a-more-complete-example">A more complete example</a></h3>
<p><code>ObjectServer</code> supports various method attributes to declare properties or signals.</p>
<p>This is a more complete example, demonstrating some of its usages. It also shows a way to
synchronize with the interface handlers from outside, thanks to the <code>event_listener</code> crate
(this is just one of the many ways).</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use zbus::{object_server::SignalEmitter, connection::Builder, interface, fdo, Result};
</span><span class="boring">
</span>use event_listener::{Event, Listener};

struct Greeter {
    name: String,
    done: Event,
}

#[interface(name = "org.zbus.MyGreeter1")]
impl Greeter {
    async fn say_hello(&amp;self, name: &amp;str) -&gt; String {
        format!("Hello {}!", name)
    }

    // Rude!
    async fn go_away(
        &amp;self,
        #[zbus(signal_emitter)]
        emitter: SignalEmitter&lt;'_&gt;,
    ) -&gt; fdo::Result&lt;()&gt; {
        emitter.greeted_everyone().await?;
        self.done.notify(1);

        Ok(())
    }

    /// A "GreeterName" property.
    #[zbus(property)]
    async fn greeter_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    /// A setter for the "GreeterName" property.
    ///
    /// Additionally, a `greeter_name_changed` method has been generated for you if you need to
    /// notify listeners that "GreeterName" was updated. It will be automatically called when
    /// using this setter.
    #[zbus(property)]
    async fn set_greeter_name(&amp;mut self, name: String) {
        self.name = name;
    }

    /// A signal; the implementation is provided by the macro.
    #[zbus(signal)]
    async fn greeted_everyone(emitter: &amp;SignalEmitter&lt;'_&gt;) -&gt; Result&lt;()&gt;;
}

// Although we use `tokio` here, you can use any async runtime of choice.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let greeter = Greeter {
        name: "GreeterName".to_string(),
        done: event_listener::Event::new(),
    };
    let done_listener = greeter.done.listen();
    let connection = Builder::session()?
        .name("org.zbus.MyGreeter")?
        .serve_at("/org/zbus/MyGreeter", greeter)?
        .build()
        .await?;

    done_listener.wait();

    // Let's emit the signal again, just for the fun of it.
    connection
        .object_server()
        .interface("/org/zbus/MyGreeter")
        .await?
        .greeted_everyone()
        .await?;

    Ok(())
}</code></pre></pre>
<p>This is the introspection result:</p>
<pre><code class="language-bash">$ busctl --user introspect org.zbus.MyGreeter /org/zbus/MyGreeter
NAME                                TYPE      SIGNATURE RESULT/VALUE FLAGS
[...]
org.zbus.MyGreeter1                 interface -         -             -
.GoAway                             method    -         -             -
.SayHello                           method    s         s             -
.GreeterName                        property  s         "GreeterName" emits-change writable
.GreetedEveryone                    signal    -         -             -
</code></pre>
<h3 id="trait-bounds-for-property-values-1"><a class="header" href="#trait-bounds-for-property-values-1">Trait-bounds for property values</a></h3>
<p>If you use custom types for property values, you might get a compile error for missing
<code>TryFrom&lt;zvariant::Value&lt;'_&gt;&gt;</code> and/or <code>TryFrom&lt;OwnedValue&gt;</code> implementations. This is because
properties are always sent as Variants on the bus, so you need to implement these conversions for
your custom types.</p>
<p>Not to worry though, the <code>zvariant</code> crate provides a <a href="https://docs.rs/zvariant/5/zvariant/derive.Value.html"><code>Value</code></a> and <a href="https://docs.rs/zvariant/5/zvariant/derive.OwnedValue.html"><code>OwnedValue</code></a> derive macro to
implement these conversions for you.</p>
<h3 id="method-errors"><a class="header" href="#method-errors">Method errors</a></h3>
<p>There are two possibilities for the return value of interface methods. The first is for infallible
method calls, where the return type is a directly serializable value, like the <code>String</code> in
<code>say_hello()</code> above.</p>
<p>The second is a result return value, where the <code>Ok</code> variant is the serializable value, and the
error is any type that implements <a href="https://docs.rs/zbus/5/zbus/trait.DBusError.html"><code>zbus::DBusError</code></a>. The <a href="https://docs.rs/zbus/5/zbus/fdo/enum.Error.html"><code>zbus::fdo::Error</code></a> type implements this
trait, and should cover most common use cases. However, when a custom error type needs to be emitted
from the method as an error reply, it can be created using <code>derive(zbus::DBusError)</code>, and used in
the returned <code>Result&lt;T, E&gt;</code>.</p>
<p>Property methods may also return errors, but they must be <a href="https://docs.rs/zbus/5/zbus/fdo/enum.Error.html"><code>zbus::fdo::Error</code></a>. Most often you’ll
want to use <a href="https://docs.rs/zbus/5/zbus/fdo/enum.Error.html#variant.UnknownProperty"><code>zbus::fdo::Error::UnknownProperty</code></a> variant.</p>
<h3 id="sending-signals"><a class="header" href="#sending-signals">Sending signals</a></h3>
<p>As you might have noticed in the previous example, the signal methods don’t take a <code>&amp;self</code> argument
but a <code>SignalEmitter</code> reference. While this allows to emit signals whether from inside or outside of
the <code>interface</code> methods’ context, it does make it a bit inconvenient to use. To make things easier
<code>interface</code> generates a trait, <code>GreeterSignals</code> that provides the same signal methods but
without the <code>SignalEmitter</code> argument. The macro provides two implementations of this trait for:</p>
<ul>
<li><code>zbus::object_server::InterfaceRef&lt;Greeter&gt;</code></li>
<li><code>zbus::object_server::SignalEmitter</code></li>
</ul>
<p>The former is useful for emitting signals from outside the context of an <code>interface</code> method and the
latter is useful for emitting signals from inside of it. To make it possible to emit signals from
inside of an <code>interface</code> method, methods can ask to receive a <code>SignalEmitter</code> passed to them using
the special <code>zbus(signal_emitter)</code> attribute.</p>
<p>Please refer to <a href="https://docs.rs/zbus/5/zbus/attr.interface.html"><code>interface</code> documentation</a> for more examples and list of other special
attributes you can make use of.</p>
<p>We saw examples of signal emission in action, from both inside and outside an <code>interface</code> method, in
the previous example.</p>
<h3 id="notifying-property-changes"><a class="header" href="#notifying-property-changes">Notifying property changes</a></h3>
<p>For each property declared through the <code>interface</code> macro, a <code>&lt;property_name&gt;_changed</code> method is
generated that emits the necessary property change signal. Here is how to use it with the previous
example code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use zbus::interface;
</span><span class="boring">
</span><span class="boring">struct Greeter {
</span><span class="boring">    name: String
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[interface(name = "org.zbus.MyGreeter1")]
</span><span class="boring">impl Greeter {
</span><span class="boring">    #[zbus(property)]
</span><span class="boring">    async fn greeter_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[zbus(property)]
</span><span class="boring">    async fn set_greeter_name(&amp;mut self, name: String) {
</span><span class="boring">        self.name = name;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; zbus::Result&lt;()&gt; {
</span><span class="boring">let connection = zbus::Connection::session().await?;
</span><span class="boring">let object_server = connection.object_server();
</span>
let iface_ref = object_server.interface::&lt;_, Greeter&gt;("/org/zbus/MyGreeter").await?;
let mut iface = iface_ref.get_mut().await;
iface.name = String::from("👋");
iface.greeter_name_changed(iface_ref.signal_emitter()).await?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<h2 id="proxy-generation"><a class="header" href="#proxy-generation">Proxy generation</a></h2>
<p><code>interface</code> macro can also generate the client-side proxy code for you. It utilizes the <a href="https://docs.rs/zbus/5/zbus/attr.proxy.html"><code>proxy</code></a>
macro behind the scenes to achieve this. Here is how to use it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use zbus::interface;

struct Greeter {
    name: String
}

#[interface(
    name = "org.zbus.MyGreeter.WithProxy",
    // Specifying the `proxy` attribute instructs `interface` to generate the
    // client-side proxy. You can specify proxy-specific attributes
    // (e.g `gen_blocking) here. All the attributes that are common between
    // `proxy` and `interface` macros (e.g `name`) are automtically forwarded to
    // the `proxy` macro.
    proxy(
        gen_blocking = false,
        default_path = "/org/zbus/MyGreeter/WithProxy",
        default_service = "org.zbus.MyGreeter.WithProxy",
    ),
)]
impl Greeter {
    #[zbus(property)]
    async fn greeter_name(&amp;self) -&gt; String {
        self.name.clone()
    }

    #[zbus(proxy(no_reply))]
    async fn whatever(&amp;self) {
        println!("Whatever!");
    }
}

<span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; zbus::Result&lt;()&gt; {
</span>
let greeter = Greeter { name: "GreeterName".to_string() };
let connection = zbus::connection::Builder::session()?
        .name("org.zbus.MyGreeter.WithProxy")?
        .serve_at("/org/zbus/MyGreeter/WithProxy", greeter)?
        .build()
        .await?;
let proxy = GreeterProxy::new(&amp;connection).await?;
assert_eq!(proxy.greeter_name().await?, "GreeterName");
proxy.whatever().await?;

<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<h3 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h3>
<p>While it’s extremely useful to be able to generate the client-side proxy code directly from
<code>interface</code> as it allows you to avoid duplicating code, there are some limitations to be aware of:</p>
<ul>
<li>The trait bounds of the <code>proxy</code> macro methods’ arguments and return value, now also apply to the
<code>interface</code> methods. For example, when only generating the service-side code, the method return
values need to implement <code>serde::Serialize</code> but when generating the client-side proxy code, the
method return values need to implement <code>serde::DeserializeOwned</code> as well.</li>
<li>Reference types in return values of <code>interface</code> methods won’t work. As you may have noticed,
unlike the previous examples the <code>greeter_name</code> method in the example above returns a <code>String</code>
instead of a <code>&amp;str</code>. This is because the methods in the <code>proxy</code> macro do not support reference
type to be returned from its methods.</li>
<li>Methods returning [<code>object_server::ResponseDispatchNotifier</code>] wrapper type will do the same for
proxy as well.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocking-api"><a class="header" href="#blocking-api">Blocking API</a></h1>
<ul>
<li><a href="blocking.html#establishing-a-connection">Establishing a connection</a></li>
<li><a href="blocking.html#client">Client</a>
<ul>
<li><a href="blocking.html#watching-for-properties">Watching for properties</a></li>
</ul>
</li>
<li><a href="blocking.html#server">Server</a></li>
</ul>
<p>While zbus API being primarily asynchronous (since 2.0) is a great thing, it could easily feel
daunting for simple use cases. Not to worry! In the spirit of “ease” being a primary goal of zbus,
it provides blocking wrapper types, under the <a href="https://docs.rs/zbus/5/zbus/blocking/index.html">blocking module</a>.</p>
<p><strong>Note:</strong> Use of the blocking API presented in this chapter in an async context will likely result
in panics and hangs. This is not a limitation of zbus but rather a
<a href="https://rust-lang.github.io/wg-async-foundations/vision/shiny_future/users_manual.html#caveat-beware-the-async-sandwich">well-known general problem</a> in the Rust async/await world. The <a href="https://docs.rs/blocking/"><code>blocking</code> crate</a>,
<a href="https://docs.rs/async-std/4/async_std/task/fn.spawn_blocking.html"><code>async-std</code></a> and <a href="https://docs.rs/tokio/4/tokio/task/fn.spawn_blocking.html"><code>tokio</code></a> crates provide a easy way around this problem.</p>
<p><strong>Note:</strong> Since zbus 5.0, blocking API can be disabled through the <code>blocking-api</code> cargo feature. If
you use this API, make sure you are not unintentionally disabling it by disabling the default
features in your <code>Cargo.toml</code>.</p>
<h2 id="establishing-a-connection-1"><a class="header" href="#establishing-a-connection-1">Establishing a connection</a></h2>
<p>The only difference to that of <a href="https://docs.rs/zbus/5/zbus/connection/struct.Connection.html">asynchronous <code>Connection</code> API</a> is that you use
<a href="https://docs.rs/zbus/5/zbus/blocking/connection/struct.Connection.html"><code>blocking::Connection</code></a> type instead. This type’s API is almost identical to that of <code>Connection</code>,
except all its methods are blocking.</p>
<h2 id="client"><a class="header" href="#client">Client</a></h2>
<p>Similar to <code>blocking::Connection</code>, you use <code>blocking::Proxy</code> type. Its constructors require
<code>blocking::Connection</code> instead of <code>Connection</code>. Moreover, <code>proxy</code> macro generates a
<code>blocking::Proxy</code> wrapper for you as well. Let’s convert the last example in the previous chapter,
to use the blocking connection and proxy:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zbus::{blocking::Connection, zvariant::ObjectPath, proxy, Result};

#[proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Manager",
    default_path = "/org/freedesktop/GeoClue2/Manager"
)]
trait Manager {
    #[zbus(object = "Client")]
    /// The method normally returns an `ObjectPath`.
    /// With the object attribute, we can make it return a `ClientProxy` directly.
    fn get_client(&amp;self);
}

#[proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Client"
)]
trait Client {
    fn start(&amp;self) -&gt; Result&lt;()&gt;;
    fn stop(&amp;self) -&gt; Result&lt;()&gt;;

    #[zbus(property)]
    fn set_desktop_id(&amp;mut self, id: &amp;str) -&gt; Result&lt;()&gt;;

    #[zbus(signal)]
    fn location_updated(&amp;self, old: ObjectPath&lt;'_&gt;, new: ObjectPath&lt;'_&gt;) -&gt; Result&lt;()&gt;;
}

#[proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Location"
)]
trait Location {
    #[zbus(property)]
    fn latitude(&amp;self) -&gt; Result&lt;f64&gt;;
    #[zbus(property)]
    fn longitude(&amp;self) -&gt; Result&lt;f64&gt;;
}
let conn = Connection::system().unwrap();
let manager = ManagerProxyBlocking::new(&amp;conn).unwrap();
let mut client = manager.get_client().unwrap();
// Gotta do this, sorry!
client.set_desktop_id("org.freedesktop.zbus").unwrap();

let mut location_updated = client.receive_location_updated().unwrap();

client.start().unwrap();

// Wait for the signal.
let signal = location_updated.next().unwrap();
let args = signal.args().unwrap();

let location = LocationProxyBlocking::builder(&amp;conn)
    .path(args.new())
    .unwrap()
    .build()
    .unwrap();
println!(
    "Latitude: {}\nLongitude: {}",
    location.latitude().unwrap(),
    location.longitude().unwrap(),
);
<span class="boring">}</span></code></pre></pre>
<p>As you can see, nothing changed in the <code>proxy</code> usage here and the rest largely remained the
same as well. One difference that’s not obvious is that the blocking API for receiving signals,
implement <a href="https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html"><code>std::iter::Iterator</code></a> trait instead of <a href="https://docs.rs/futures/0.3.17/futures/stream/trait.Stream.html"><code>futures::stream::Stream</code></a>.</p>
<h3 id="watching-for-properties"><a class="header" href="#watching-for-properties">Watching for properties</a></h3>
<p>That’s almost the same as receiving signals:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use zbus::{blocking::Connection, proxy, Result};
</span><span class="boring">
</span>#[proxy(
    interface = "org.freedesktop.systemd1.Manager",
    default_service = "org.freedesktop.systemd1",
    default_path = "/org/freedesktop/systemd1"
)]
trait SystemdManager {
    #[zbus(property)]
    fn log_level(&amp;self) -&gt; zbus::Result&lt;String&gt;;
}

fn main() -&gt; Result&lt;()&gt; {
    let connection = Connection::session()?;

    let proxy = SystemdManagerProxyBlocking::new(&amp;connection)?;
    let v = proxy.receive_log_level_changed().next().unwrap();
    println!("LogLevel changed: {:?}", v.get());

    Ok(())
}</code></pre></pre>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>Similarly here, you’d use [<code>blocking::ObjectServer</code>] that is associated with every
<a href="https://docs.rs/zbus/5/zbus/blocking/connection/struct.Connection.html"><code>blocking::Connection</code></a> instance. While there is no blocking version of <code>Interface</code>,
<code>interface</code> allows you to write non-async methods.</p>
<p><strong>Note:</strong> Even though you can write non-async methods, these methods are still called from an async
context. Therefore, you can not use blocking API in the method implementation directly. See note at
the beginning of this chapter for details on why and a possible workaround.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::error::Error;
</span><span class="boring">use zbus::{blocking::connection, interface, fdo, object_server::SignalEmitter};
</span><span class="boring">
</span>use event_listener::{Event, Listener};

struct Greeter {
    name: String,
    done: Event,
}

#[interface(name = "org.zbus.MyGreeter1")]
impl Greeter {
    fn say_hello(&amp;self, name: &amp;str) -&gt; String {
        format!("Hello {}!", name)
    }

    // Rude!
    async fn go_away(
        &amp;self,
        #[zbus(signal_emitter)]
        emitter: SignalEmitter&lt;'_&gt;,
    ) -&gt; fdo::Result&lt;()&gt; {
        emitter.greeted_everyone().await?;
        self.done.notify(1);

        Ok(())
    }

    /// A "GreeterName" property.
    #[zbus(property)]
    fn greeter_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    /// A setter for the "GreeterName" property.
    ///
    /// Additionally, a `greeter_name_changed` method has been generated for you if you need to
    /// notify listeners that "GreeterName" was updated. It will be automatically called when
    /// using this setter.
    #[zbus(property)]
    fn set_greeter_name(&amp;mut self, name: String) {
        self.name = name;
    }

    /// A signal; the implementation is provided by the macro.
    #[zbus(signal)]
    async fn greeted_everyone(emitter: &amp;SignalEmitter&lt;'_&gt;) -&gt; zbus::Result&lt;()&gt;;
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeter = Greeter {
        name: "GreeterName".to_string(),
        done: event_listener::Event::new(),
    };
    let done_listener = greeter.done.listen();
    let _handle = connection::Builder::session()?
        .name("org.zbus.MyGreeter")?
        .serve_at("/org/zbus/MyGreeter", greeter)?
        .build()?;

    done_listener.wait();

    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<ul>
<li><a href="faq.html#how-to-use-a-struct-as-a-dictionary">How to use a struct as a dictionary?</a></li>
<li><a href="faq.html#why-do-async-tokio-api-calls-from-interface-methods-not-work">Why do async tokio API calls from interface methods not work?</a></li>
<li><a href="faq.html#im-experiencing-hangs-what-could-be-wrong">I’m experiencing hangs, what could be wrong?</a>
<ul>
<li><a href="faq.html#1-a-interface-method-that-takes-a-mut-self-argument-is-taking-too-long">1. A <code>interface</code> method that takes a <code>&amp;mut self</code> argument is taking too long</a></li>
<li><a href="faq.html#2-a-stream-eg-signalstream-is-not-being-continuously-polled">2. A stream (e.g <code>SignalStream</code>) is not being continuously polled</a></li>
</ul>
</li>
<li><a href="faq.html#why-arent-property-values-updating-for-my-service-that-doesnt-notify-changes">Why aren’t property values updating for my service that doesn’t notify changes?</a></li>
<li><a href="faq.html#how-do-i-use-optiont-with-zbus">How do I use <code>Option&lt;T&gt;</code> with zbus?</a>
<ul>
<li><a href="faq.html#1-designation-of-a-special-value-as-none">1. Designation of a special value as <code>None</code></a></li>
<li><a href="faq.html#2-encoding-as-an-array-a">2. Encoding as an array (<code>a?</code>)</a></li>
</ul>
</li>
<li><a href="faq.html#how-do-enums-work">How do enums work?</a></li>
</ul>
<h2 id="how-to-use-a-struct-as-a-dictionary"><a class="header" href="#how-to-use-a-struct-as-a-dictionary">How to use a struct as a dictionary?</a></h2>
<p>Since the use of a dictionary, specifically one with strings as keys and variants as value (i-e
<code>a{sv}</code>) is very common in the D-Bus world and use of HashMaps isn’t as convenient and type-safe as
a struct, you might find yourself wanting to use a struct as a dictionary.</p>
<p>It’s possible to do so, using either of the following methods:</p>
<ol>
<li>Using the <code>SerializeDict</code> and <code>DeserializeDict</code> derive macros from <code>zvariant</code>. This is the best
option for simple cases.</li>
<li>Using the <code>Serialize</code> and <code>Deserialize</code> derive macros from the <code>serde</code> crate. This is the best
option for more complex cases, where you need more fine-grained control over the serialization
and/or deserialization process.</li>
</ol>
<p>Here is a simple example using <code>SerializeDict</code> and <code>DeserializeDict</code>:</p>
<pre><code class="language-rust noplayground">use zbus::{
    proxy, interface, fdo::Result,
    zvariant::{Type, SerializeDict, DeserializeDict},
};

#[derive(DeserializeDict, SerializeDict, Type)]
// `Type` treats `dict` is an alias for `a{sv}`.
#[zvariant(signature = "dict")]
pub struct Dictionary {
    field1: u16,
    #[zvariant(rename = "another-name")]
    field2: i64,
    optional_field: Option&lt;String&gt;,
}

#[proxy(
    interface = "org.zbus.DictionaryGiver",
    default_path = "/org/zbus/DictionaryGiver",
    default_service = "org.zbus.DictionaryGiver",
)]
trait DictionaryGiver {
    fn give_me(&amp;self) -&gt; Result&lt;Dictionary&gt;;
}

struct DictionaryGiverInterface;

#[interface(interface = "org.zbus.DictionaryGiver")]
impl DictionaryGiverInterface {
    fn give_me(&amp;self) -&gt; Result&lt;Dictionary&gt; {
        Ok(Dictionary {
            field1: 1,
            field2: 4,
            optional_field: Some(String::from("blah")),
        })
    }
}</code></pre>
<p>Now let’s say you want to grab all the extra entries that are not explicitly defined in the
struct. You can not do that with <code>DeserializeDict</code> but you can with <code>serde::Deserialize</code>:</p>
<pre><code class="language-rust noplayground">use std::collections::HashMap;
use zbus::zvariant::{Type, OwnedValue, as_value::{self, optional}};
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Type)]
#[zvariant(signature = "dict")]
pub struct Dictionary {
    #[serde(with = "as_value")]
    field1: u16,
    #[serde(rename = "another-name", with = "as_value")]
    field2: i64,
    #[serde(
        with = "optional",
        skip_serializing_if = "Option::is_none",
        default,
    )]
    optional_field: Option&lt;String&gt;,
    #[serde(flatten)]
    the_rest: HashMap&lt;String, OwnedValue&gt;,
}</code></pre>
<p>Since the fields have to be transformed from/into <code>zvariant::Value</code>, make sure to use the <code>with</code>
attribute with the appropriate helper module from <code>zvariant::as_value</code> module.</p>
<p>Moreover, since D-Bus does not have a concept of nullable types, it’s important to ensure that
<code>skip_serializing_if</code> and <code>default</code> attributes are used for optional fields. Fortunately, you can
make use of the <code>default</code> container attribute if your struct can implemented the <code>Default</code> trait:</p>
<pre><code class="language-rust noplayground"><span class="boring">use zbus::zvariant::{Type, as_value::{self, optional}};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Default, Deserialize, Serialize, Type)]
#[zvariant(signature = "dict")]
#[serde(default)]
pub struct Dictionary {
    #[serde(with = "as_value")]
    field1: u16,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none")]
    optional_field1: Option&lt;i64&gt;,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none")]
    optional_field2: Option&lt;String&gt;,
}</code></pre>
<h2 id="why-do-async-tokio-api-calls-from-interface-methods-not-work"><a class="header" href="#why-do-async-tokio-api-calls-from-interface-methods-not-work">Why do async tokio API calls from interface methods not work?</a></h2>
<p>Many of the tokio (and tokio-based) APIs assume the tokio runtime to be driving the async machinery
and since by default, zbus runs the <code>ObjectServer</code> in its own internal runtime thread, it’s not
possible to use these APIs from interface methods. Moreover, by default zbus relies on <code>async-io</code>
crate to communicate with the bus, which uses its own thread.</p>
<p>Not to worry, though! You can enable tight integration between tokio and zbus by enabling <code>tokio</code>
feature:</p>
<pre><code class="language-toml"># Sample Cargo.toml snippet.
[dependencies]
# Also disable the default `async-io` feature to avoid unused dependencies.
zbus = { version = "3", default-features = false, features = ["tokio"] }
</code></pre>
<p><strong>Note</strong>: On Windows, the <code>async-io</code> feature is currently required for UNIX domain socket support,
see <a href="https://github.com/tokio-rs/tokio/issues/2201">the corresponding tokio issue on GitHub</a>.</p>
<h2 id="im-experiencing-hangs-what-could-be-wrong"><a class="header" href="#im-experiencing-hangs-what-could-be-wrong">I’m experiencing hangs, what could be wrong?</a></h2>
<p>There are typically two reasons this can happen with zbus:</p>
<h3 id="1-a-interface-method-that-takes-a-mut-self-argument-is-taking-too-long"><a class="header" href="#1-a-interface-method-that-takes-a-mut-self-argument-is-taking-too-long">1. A <code>interface</code> method that takes a <code>&amp;mut self</code> argument is taking too long</a></h3>
<p>Simply put, this is because of one of the primary rules of Rust: while a mutable reference to a
resource exists, no other references to that same resource can exist at the same time. This means
that before the method in question returns, all other method calls on the providing interface will
have to wait in line.</p>
<p>A typical solution here is use of interior mutability or launching tasks to do the actual work
combined with signals to report the progress of the work to clients. Both of these solutions
involve converting the methods in question to take <code>&amp;self</code> argument instead of <code>&amp;mut self</code>.</p>
<h3 id="2-a-stream-eg-signalstream-is-not-being-continuously-polled"><a class="header" href="#2-a-stream-eg-signalstream-is-not-being-continuously-polled">2. A stream (e.g <code>SignalStream</code>) is not being continuously polled</a></h3>
<p>Please consult <a href="https://docs.rs/zbus/5/zbus/struct.MessageStream.html"><code>MessageStream</code></a> documentation for details.</p>
<h2 id="why-arent-property-values-updating-for-my-service-that-doesnt-notify-changes"><a class="header" href="#why-arent-property-values-updating-for-my-service-that-doesnt-notify-changes">Why aren’t property values updating for my service that doesn’t notify changes?</a></h2>
<p>A common issue might arise when using a zbus proxy is that your proxy’s property values aren’t
updating. This is due to zbus’ default caching policy, which updates the value of a property only
when a change is signaled, primarily to minimize latency and optimize client request performance.
By default, if your service does not emit change notifications, the property values will not
update accordingly.</p>
<p>However, you can disabling caching for specific properties:</p>
<ul>
<li>
<p>Add the <code>#[zbus(property(emits_changed_signal = "false"))]</code> annotation to the property for which
you desire to disable caching on. For more information about all the possible values for
<code>emits_changed_signal</code> refer to <a href="https://docs.rs/zbus/5/zbus/attr.proxy.html"><code>proxy</code></a> documentation.</p>
</li>
<li>
<p>Use <code>proxy::Builder</code> to build your proxy instance and use <a href="https://docs.rs/zbus/5/zbus/proxy/struct.Builder.html#method.uncached_properties"><code>proxy::Builder::uncached_properties</code></a>
method to list all properties you wish to disable caching for.</p>
</li>
<li>
<p>In order to disable caching for either type of proxy use the <a href="https://docs.rs/zbus/5/zbus/proxy/struct.Builder.html#method.cache_properties"><code>proxy::Builder::cache_properites</code></a>
method.</p>
</li>
</ul>
<h2 id="how-do-i-use-optiont-with-zbus"><a class="header" href="#how-do-i-use-optiont-with-zbus">How do I use <code>Option&lt;T&gt;</code> with zbus?</a></h2>
<p>While <code>Option&lt;T&gt;</code> is a very commonly used type in Rust, there is unfortunately <a href="https://gitlab.freedesktop.org/dbus/dbus/-/issues/25">no concept of a
nullable-type in the D-Bus protocol</a>. However, there are two ways to simulate it:</p>
<h3 id="1-designation-of-a-special-value-as-none"><a class="header" href="#1-designation-of-a-special-value-as-none">1. Designation of a special value as <code>None</code></a></h3>
<p>This is the simplest way to simulate <code>Option&lt;T&gt;</code>. Typically the
default value for the type in question is a good choice. For example the empty string (<code>""</code>) is
often used as <code>None</code> for strings and string-based types. Note however that this solution can not
work for all types, for example <code>bool</code>.</p>
<p>Since this is the most widely used solution in the D-Bus world and is even used by the <a href="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces">D-Bus
standard interfaces</a>, <code>zvariant</code> provides a custom type for this, <a href="https://docs.rs/zvariant/5/zvariant/struct.Optional.html"><code>Optional&lt;T&gt;</code></a> that makes
it super easy to simulate a nullable type, especially if the contained type implements the <code>Default</code>
trait.</p>
<h3 id="2-encoding-as-an-array-a"><a class="header" href="#2-encoding-as-an-array-a">2. Encoding as an array (<code>a?</code>)</a></h3>
<p>The idea here is to represent <code>None</code> case with 0 elements (empty array) and the <code>Some</code> case with 1
element. <code>zvariant</code> and <code>zbus</code> provide <code>option-as-array</code> Cargo feature, which when enabled, allows
the (de)serialization of <code>Option&lt;T&gt;</code>. Unlike the previous solution, this solution can be used with
all types. However, it does come with some caveats and limitations:</p>
<ol>
<li>Since the D-Bus type signature does not provide any hints about the array being in fact a
nullable type, this can be confusing for users of generic tools like <a href="https://wiki.gnome.org/Apps/DFeet"><code>d-feet</code></a>. It is therefore
highly recommended that service authors document each use of <code>Option&lt;T&gt;</code> in their D-Bus
interface documentation.</li>
<li>Currently it is not possible to use <code>Option&lt;T&gt;</code> for <code>interface</code> and <code>proxy</code> property
methods.</li>
<li>Both the sender and receiver must agree on use of this encoding. If the sender sends <code>T</code>, the
receiver will not be able to decode it successfully as <code>Option&lt;T&gt;</code> and vice versa.</li>
<li>While <code>zvariant::Value</code> can be converted into <code>Option&lt;T&gt;</code>, the reverse is currently not
possible.</li>
</ol>
<p>Due to these limitations, <code>option-as-array</code> feature is not enabled by default and must be explicitly
enabled.</p>
<p><strong>Note</strong>: We hope to be able to remove #2 and #4, once <a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialization</a> lands in stable Rust.</p>
<h2 id="how-do-enums-work"><a class="header" href="#how-do-enums-work">How do enums work?</a></h2>
<p>By default, <code>zvariant</code> encodes an unit-type enum as a <code>u32</code>, denoting the variant index. Other enums
are encoded as a structure whose first field is the variant index and the second one are the
variant’s field(s). The only caveat here is that all variants must have the same number and types
of fields. Names of fields don’t matter though. You can make use of <a href="https://docs.rs/zvariant/5/zvariant/enum.Value.html"><code>Value</code></a> or <a href="https://docs.rs/zvariant/5/zvariant/struct.OwnedValue.html"><code>OwnedValue</code></a> if you want to encode different data in different fields. Here is a simple example:</p>
<pre><code class="language-rust noplayground">use zbus::zvariant::{serialized::Context, to_bytes, Type, LE};
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Type, PartialEq, Debug)]
enum Enum&lt;'s&gt; {
    Variant1 { field1: u16, field2: i64, field3: &amp;'s str },
    Variant2(u16, i64, &amp;'s str),
    Variant3 { f1: u16, f2: i64, f3: &amp;'s str },
}

let e = Enum::Variant3 {
    f1: 42,
    f2: i64::max_value(),
    f3: "hello",
};
let ctxt = Context::new_dbus(LE, 0);
let encoded = to_bytes(ctxt, &amp;e).unwrap();
let decoded: Enum = encoded.deserialize().unwrap().0;
assert_eq!(decoded, e);</code></pre>
<p>Enum encoding can be adjusted by using the <a href="https://crates.io/crates/serde_repr"><code>serde_repr</code></a> crate and by annotating the representation of the enum with <code>repr</code>:</p>
<pre><code class="language-rust noplayground">use zbus::zvariant::{serialized::Context, to_bytes, Type, LE};
use serde_repr::{Serialize_repr, Deserialize_repr};

#[derive(Deserialize_repr, Serialize_repr, Type, PartialEq, Debug)]
#[repr(u8)]
enum UnitEnum {
    Variant1,
    Variant2,
    Variant3,
}

let ctxt = Context::new_dbus(LE, 0);
let encoded = to_bytes(ctxt, &amp;UnitEnum::Variant2).unwrap();
let e: UnitEnum = encoded.deserialize().unwrap().0;
assert_eq!(e, UnitEnum::Variant2);</code></pre>
<p>Unit enums can also be (de)serialized as strings:</p>
<pre><code class="language-rust noplayground">use zbus::zvariant::{serialized::Context, to_bytes, Type, LE};
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Type, PartialEq, Debug)]
#[zvariant(signature = "s")]
enum StrEnum {
    Variant1,
    Variant2,
    Variant3,
}

let ctxt = Context::new_dbus(LE, 0);
let encoded = to_bytes(ctxt, &amp;StrEnum::Variant2).unwrap();
let e: StrEnum = encoded.deserialize().unwrap().0;
assert_eq!(e, StrEnum::Variant2);
let s: &amp;str = encoded.deserialize().unwrap().0;
assert_eq!(s, "Variant2");</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of the contributors who have helped improving zbus. Big shout-out to them!</p>
<ul>
<li>Zeeshan Ali Khan (<a href="https://github.com/zeenix">@zeenix</a>)</li>
<li>Marc-André Lureau (<a href="https://github.com/elmarco">@elmarco</a>)</li>
</ul>
<p>If you feel you’re missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
